# 实验大致思路（注：采取的是Verilog方式完成硬件实现

## 核心部分：md5.v和md5round.v

### 第一步：完成defs.v的静态变量S[]和K[]的定义

> 注意事项：S[]和K[]在定义的实现上，需要在{}前加上==**'**==否则会报错

### 第二步：对于md5round.v的代码补全

> 定义结果寄存器以及assign next_a与各项数据之间的连线
>
> > 注意：在该部分需要调用四个计算函数 FGHI
> >
> > - 采取 底层Verilog书写，逐层调用的方法
> > - 分别书写 F.v  G.v H.v I.v的简易代码
>
> 分case 表示结果寄存器该使用哪个函数的结果作为加数

### 第三步：对于md5.v的代码补全

> 1. 定义好md5round.v中所需传入的寄存器
>
> 2. 更新 A B C D
>
>    - 根据判断 next state[0]的状态 更新A B C D是该为init还是next
>
> 3. 更新 phase
>
>    - phase实际上表示的是.c代码中的 for 循环的 i
>
> 4. 初始化变量
>
> 5. 四个round的计算递进
>
>    > - 这几个阶段对cya、cyb、cyc、cyd的取值选择都是按照一样的规律case
>    > - 根据state[]进行各个round的选择计算
>    > - 在每个round中，需要注意r_out等于的是哪个next_(ABCD)
>    > - 更新md5round.v各个传入的参数值
>    > - 对于r_m、r_s、r_t这三个则需要特别注意位宽以及指向的位置
>    > - 循环结束判断：phase=4'b1111
>    > - 四个round整体上的逻辑是一样的